/*************************************************************************
功能：创建单向有头结点链表
方法特点：头插法，逆序输出
输入参数：x
说明：元素每次插入的时候从头结点插入，头结点始终指向新插入的元素**************************************************************************/
void CreatList(LNode *head, int n)
{
	LNode *p;
	int x;
	head->next = NULL;
	for (int i = n; i > 0; i--)
	{
		p = new LNode;
		cin >> x;
		p->data = x;
		p->next = head->next;
		head->next = p;
	}
}
/*************************************************************************
功能：创建单向有头结点链表
方法特点：尾插法，正序输出
输入参数：x
说明：建立头节点，元素插入时每次都从尾部插入，新插入的元素总指向最后，即NULL；
**************************************************************************/
void CreatList(LNode *head)
{
	LNode *p, *q;
	int x;
	q = head;
	while (1)
	{
		cin >> x;
		if (x == 0)
			break;
		p = new LNode;
		p->data = x;
		q->next = p;
		q = p;
	}
	q->next = NULL;
}
/**************************************************************************
功能：在指定位置前插入元素
输入参数：位置i,元素x
说明：插入的关键就是将插入的元素与i个元素链接，再找到第i个元素的前一个元素，让它指向要插入的元素即可.
**************************************************************************/
void InsertList(LNode *head, int n, int i, int x)
{
	LNode *p, *q;
	q = new LNode;
	int j = 0;
	p = head;
	while (j < i - 1 && p)
	{
		p = p->next;
		j++;
	}
	if (!p)
		cout << -1 << endl;
	else
	{
		q->data = x;
		q->next = p->next;
		p->next = q;
		PrintList(head);
		cout << endl;
	}
}
/*************************************************************************
功能：在指定位置删除元素
输入参数：位置j
说明：关键是找到要删除元素的前一个元素，即第j-1个元素，然后还要保证(p->next)!=NULL，即第i个元素的下一个元素不能为空，这样才能顺利将第j-1个元素于第j+1个元素相链接，从而达到删除的目的.
**************************************************************************/
void DelList(LNode *head, int n, int j)
{
	LNode *p, *q;
	p = head;
	int i = 0;
	while (p->next&&i < j - 1)
	{
		p = p->next;
		i++;
	}
	if (!(p->next)
		cout << -1 << endl;
	else
	{
		q = p->next;
			p->next = q->next;
			PrintList(head);
			cout << endl;
	}
}
/*************************************************************************
功能：查找指定元素
输入参数：y
说明：利用循环遍历链表，直到找到跳出循环，从而得到指定位置.
**************************************************************************/
void SearchList(LNode *head, int y)
{
	LNode *p;
	p = head->next;
	int i = 1;
	while (p&&p->data != y)
	{
		p = p->next;
		i++;
	}
	if (p == NULL)
		cout << -1 << endl;
	else
		cout << i << endl;
}
/*************************************************************************
功能：求链表长度
说明:利用循环直到表尾，再用i计数即可得到表长.
**************************************************************************/
int Length(LNode *head)
{
	LNode *p;
	p = head->next;
	int i = 0;
	while (p)
	{
		p = p->next;
		i++;
	}
	return i;
}
/*************************************************************************
功能：打印表
说明：遍历输出即可
**************************************************************************/
void PrintList(LNode *head)
{
	LNode *p;
	p = head;
	p = p->next;
	while (p)
	{
		cout << p->data << " ";
		p = p->next;
	}
}
/***********************************************************************
功能：销毁表
说明：while循环遍历，删除每个结点.
************************************************************************/
void destroy(LNode *head)
{
	LNode *p;
	p = head->next;
	while (p)
	{
		delete p;
		p = p->next;
	}
}
/**************************************************************************
功能：逆置表
说明：表的逆置是在同一张表中操作的，根据已经创建好的表，首先从表头进行遍历并保存第一个结点，然后从第二个结点开始，顺序移动指针，每次都将指针指向的元素和表头链接，直到表尾，从而改变元素的顺序.
**************************************************************************/
void Reverse(LNode *head)
{
	LNode *p, *q;
	p = head->next;
	head->next = NULL;
	while (p)
	{
		q = p;
		p = p->next;
		q->next = head->next;
		head->next = q;
	}
}
/*************************************************************************
功能：表去重
说明：该方法是在同一张表中进行操作的，主要操作就是以头结点及第一个结点为引导存储去重表（记为p)，在以第二个结点为首（记为q)顺序遍历，并且p中的元素同时和q比较，若相等则跳过，该元素不与p进行链接;反之进行链接.
*************************************************************************/
void Rev_same(LNode *head)
{
	LNode *p, *q, *r, *s;
	p = head->next;
	r = head;
	int flag = 0;
	while (p)
	{
		if (flag == 0)
		{
			q = p;
			p = p->next;
			q->next = NULL;
			r->next = q;
			r = q;
		}
		s = head->next;
		while (s && p)
		{
			if (s->data == p->data)
			{
				p = p->next;
				flag = 1;
				break;
			}
			flag = 0;
			s = s->next;
		}
	}
}


/**************************************************************************
功能：合并链表
输入参数：链表ha,hb
输出值：链表hc
说明：分别建立指针pa,pa遍历表ha,hb，并用pc初始化链表hc,若pa->data < pb->data，pc链接pa,pa移动；反之，pc链接pb,pb移动；若是某张表到达表尾，则将pc链接到另一张表，从而完成合并.
**************************************************************************/
void Cmb_List(LNode *ha, LNode *hb, LNode *hc)
{
	LNode *pa, *pb, *pc;
	pa = ha->next;
	pb = hb->next;
	pc = hc;
	while (pa  && pb)
	{
		if (pa->data < pb->data)
		{
			pc->next = pa;
			pc = pa;
			pa = pa->next;
		}
		else
		{
			pc->next = pb;
			pc = pb;
			pb = pb->next;
		}
	}
	pc->next = (pa) ? pa : pb;
}
/**************************************************************************
功能：创建单向无头结点循环链表
说明：头结点置空，在建立新结点时，将通过判断头结点是否为空来初始化头结点，
每次插入的节点都作为尾结点，并将其指针域置空，直到最后将为结点和头结点相连，构成无头结点循环链表.
**************************************************************************/
LNode* CreatList(int n)
{
	LNode *h;
	LNode *r, *p;
	h = new LNode;
	h = NULL;
	r = NULL;
	for (int i = 1; i <= n; i++)
	{
		p = new LNode;
		p->data = i;
		p->next = NULL;
		if (h == NULL)
		{
			h = p;
			r = h;
		}
		else
			r->next = p;
		r = p;
	}
	r->next = h;
	return h;
}
/***********************************************************************
功能：尾插法创建单向有头结点链表
方法特点：顺序读入，顺序输出
输入参数：链表长度n
说明:由于本次题目中要求指数是顺序增加的，故采用尾插法就可以避免了排序，直接在头结点的基础上进行读取就行了.
************************************************************************/
void CreatL(poly *h, int n)
{
	poly *p, *q;
	q = h;
	int c, e;
	for (int i = 0; i < n; i++)
	{
		cin >> c >> e;
		p = new poly;
		p->coef = c;
		p->expn = e;
		q->next = p;
		q = p;
	}
	q->next = NULL;
}
/***********************************************************************
功能：实现两个多项式的相加
输入参数：三个多项式链表的头结点
输出参数：相加之后的多项式链表的头结点
说明:多项式实现相加的时候，首先分别从两个多项式的头节点进行遍历，在若第一个多项式（p）的指数域和另一个多项式（q）的指数域相同，则将它们的系数域相加作为第三个多项式（r）的系数域，指数域为两者中任意一个即可；若系数域为零，则r不创建结点，反之则创建一个结点；最后将r的头结点输出，由此得到了相加之后的的多项式链表；即为指数升序排列的多项式.
************************************************************************/
void ADD_1_2(poly *h1, poly *h2, poly *h3)
{
	poly *p, *q, *r, *s;
	p = h1->next;
	q = h2->next;
	s = h3;
	while (p&&q)
	{
		r = new poly;
		if (p->expn == q->expn)
		{
			r->coef = p->coef + q->coef;
			r->expn = p->expn;
			p = p->next;
			q = q->next;
		}
		else if (p->expn < q->expn)
		{

			r = p;
			p = p->next;
		}
		else
		{
			r = q;
			q = q->next;
		}
		s->next = r;
		s = r;
	}
	s->next = (p) ? p : q;
}
/***********************************************************************
功能：创建单向有头结点链表
方法特点：头插法，逆序输出
输入参数：待插入元素，链表长度
说明：元素每次插入的时候从头结点插入，头结点始终指向新插入的元素；因为在
输入多项式的时候，两个多项式的数据域中的指针域都升序输入的，为了进行最终
的多项式升序输出和计算简便，我采取的是将一个多项式链表升序建立，另一个多
项式降序建立，就用到了尾插法、头插法；
************************************************************************/
void CreatLH(poly *h, int n)
{
	poly *p;
	int c, e;
	h->next = NULL;
	for (int i = n; i > 0; i--)
	{
		p = new poly;
		cin >> c >> e;
		p->coef = c;
		p->expn = e;
		p->next = h->next;
		h->next = p;
	}
}
/***********************************************************************
功能：实现两个多项式相乘
方法特点：一升一降查找
输入参数：三个多项式链表的头结点
说明：首先找出两个相乘多项式的最大指数域相加，（由于分别利用头尾插法建立
的链表故不需要特地去查找最大指数域结点，直接分别两个链表的头和尾指数域相
加即可）然后从最大指数k逐一循环递减，在每一个k下都要对每个多项式进行查找，
对第一个多项式p（降序建立的）找到第一个使p->expn<=k的结点p，然后在另一个
多项式（升序建立的）中循环查找到第一个使p->expn + q->expn >= k的结点q;然
后再次在循环中对刚才查找到的p和q进行操作，如果两者的指数域相加等于k就将系
数域相乘加到coe上，在分别进行循环查找；如果两者的指数域相加小于k,就将升序
建立的链表p，继续向后遍历；直到两者相加等于k；如果两者相加大于k,就将将于
建立的链表q向后遍历，直到两者相加等于k;这样就找到了所有指数域相加等于k的
p,q；最后对得到的coe是否为0进行结点是否建立的判断，若建立，则用头插法，
（因为输出要升序），coe清零再回到最初的循环，直到k减小到0，就完成了链表相乘。
************************************************************************/
void Mul_1_2(poly *h1, poly *h2, poly *h3)
{
	poly *p, *q, *r;
	h3->next = NULL;
	p = h1->next;
	q = h2;
	while (q->next) q = q->next;
	int max_expn = p->expn + q->expn;
	for (int k = max_expn; k >= 0; k--)
	{
		int coe = 0;
		p = h1->next;
		while (p&&p->expn > k)
			p = p->next;
		q = h2->next;
		while (q&&p&&p->expn + q->expn < k)
			q = q->next;
		while (p&&q)
		{
			if (p->expn + q->expn == k)
			{
				coe += p->coef*q->coef;
				p = p->next;
				q = q->next;
			}
			else if (p->expn + q->expn < k)
				q = q->next;
			else
				p = p->next;
		}
		if (coe != 0)
		{
			r = new poly;
			r->coef = coe;
			r->expn = k;
			r->next = h3->next;
			h3->next = r;
		}
	}
}


/*************************************************************************
功能:多项式求值
输入参数：x
说明：顺序遍历多项式链表，然后再对每个结点利用pow(x,expn)函数进行幂的求值
（x已知）；最后将每次得到的值相加即可。
*************************************************************************/
void value_poly(poly *h, int x)
{
	poly *p;
	p = h->next;
	double value = 0;
	while (p)
	{
		value += p->coef* pow(x, p->expn);
		p = p->next;
	}
	cout << setiosflags(ios::fixed) << setprecision(1) << value << endl;
}	    
