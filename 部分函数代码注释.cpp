/*************************************************************************
功能：创建单向有头结点链表
方法特点：头插法，逆序输出
输入参数：x
说明：元素每次插入的时候从头结点插入，头结点始终指向新插入的元素**************************************************************************/
void CreatList(LNode *head, int n)
{
	LNode *p;
	int x;
	head->next = NULL;
	for (int i = n; i > 0; i--)
	{
		p = new LNode;
		cin >> x;
		p->data = x;
		p->next = head->next;
		head->next = p;
	}
}
/*************************************************************************
功能：创建单向有头结点链表
方法特点：尾插法，正序输出
输入参数：x
说明：建立头节点，元素插入时每次都从尾部插入，新插入的元素总指向最后，即NULL；
**************************************************************************/
void CreatList(LNode *head)
{
	LNode *p, *q;
	int x;
	q = head;
	while (1)
	{
		cin >> x;
		if (x == 0)
			break;
		p = new LNode;
		p->data = x;
		q->next = p;
		q = p;
	}
	q->next = NULL;
}
/**************************************************************************
功能：在指定位置前插入元素
输入参数：位置i,元素x
说明：插入的关键就是将插入的元素与i个元素链接，再找到第i个元素的前一个元素，让它指向要插入的元素即可.
**************************************************************************/
void InsertList(LNode *head, int n, int i, int x)
{
	LNode *p, *q;
	q = new LNode;
	int j = 0;
	p = head;
	while (j < i - 1 && p)
	{
		p = p->next;
		j++;
	}
	if (!p)
		cout << -1 << endl;
	else
	{
		q->data = x;
		q->next = p->next;
		p->next = q;
		PrintList(head);
		cout << endl;
	}
}
/*************************************************************************
功能：在指定位置删除元素
输入参数：位置j
说明：关键是找到要删除元素的前一个元素，即第j-1个元素，然后还要保证(p->next)!=NULL，即第i个元素的下一个元素不能为空，这样才能顺利将第j-1个元素于第j+1个元素相链接，从而达到删除的目的.
**************************************************************************/
void DelList(LNode *head, int n, int j)
{
	LNode *p, *q;
	p = head;
	int i = 0;
	while (p->next&&i < j - 1)
	{
		p = p->next;
		i++;
	}
	if (!(p->next)
		cout << -1 << endl;
	else
	{
		q = p->next;
			p->next = q->next;
			PrintList(head);
			cout << endl;
	}
}
/*************************************************************************
功能：查找指定元素
输入参数：y
说明：利用循环遍历链表，直到找到跳出循环，从而得到指定位置.
**************************************************************************/
void SearchList(LNode *head, int y)
{
	LNode *p;
	p = head->next;
	int i = 1;
	while (p&&p->data != y)
	{
		p = p->next;
		i++;
	}
	if (p == NULL)
		cout << -1 << endl;
	else
		cout << i << endl;
}
/*************************************************************************
功能：求链表长度
说明:利用循环直到表尾，再用i计数即可得到表长.
**************************************************************************/
int Length(LNode *head)
{
	LNode *p;
	p = head->next;
	int i = 0;
	while (p)
	{
		p = p->next;
		i++;
	}
	return i;
}
/*************************************************************************
功能：打印表
说明：遍历输出即可
**************************************************************************/
void PrintList(LNode *head)
{
	LNode *p;
	p = head;
	p = p->next;
	while (p)
	{
		cout << p->data << " ";
		p = p->next;
	}
}
/***********************************************************************
功能：销毁表
说明：while循环遍历，删除每个结点.
************************************************************************/
void destroy(LNode *head)
{
	LNode *p;
	p = head->next;
	while (p)
	{
		delete p;
		p = p->next;
	}
}
/**************************************************************************
功能：逆置表
说明：表的逆置是在同一张表中操作的，根据已经创建好的表，首先从表头进行遍历并保存第一个结点，然后从第二个结点开始，顺序移动指针，每次都将指针指向的元素和表头链接，直到表尾，从而改变元素的顺序.
**************************************************************************/
void Reverse(LNode *head)
{
	LNode *p, *q;
	p = head->next;
	head->next = NULL;
	while (p)
	{
		q = p;
		p = p->next;
		q->next = head->next;
		head->next = q;
	}
}
/*************************************************************************
功能：表去重
说明：该方法是在同一张表中进行操作的，主要操作就是以头结点及第一个结点为引导存储去重表（记为p)，在以第二个结点为首（记为q)顺序遍历，并且p中的元素同时和q比较，若相等则跳过，该元素不与p进行链接;反之进行链接.
*************************************************************************/
void Rev_same(LNode *head)
{
	LNode *p, *q, *r, *s;
	p = head->next;
	r = head;
	int flag = 0;
	while (p)
	{
		if (flag == 0)
		{
			q = p;
			p = p->next;
			q->next = NULL;
			r->next = q;
			r = q;
		}
		s = head->next;
		while (s && p)
		{
			if (s->data == p->data)
			{
				p = p->next;
				flag = 1;
				break;
			}
			flag = 0;
			s = s->next;
		}
	}
}


/**************************************************************************
功能：合并链表
输入参数：链表ha,hb
输出值：链表hc
说明：分别建立指针pa,pa遍历表ha,hb，并用pc初始化链表hc,若pa->data < pb->data，pc链接pa,pa移动；反之，pc链接pb,pb移动；若是某张表到达表尾，则将pc链接到另一张表，从而完成合并.
**************************************************************************/
void Cmb_List(LNode *ha, LNode *hb, LNode *hc)
{
	LNode *pa, *pb, *pc;
	pa = ha->next;
	pb = hb->next;
	pc = hc;
	while (pa  && pb)
	{
		if (pa->data < pb->data)
		{
			pc->next = pa;
			pc = pa;
			pa = pa->next;
		}
		else
		{
			pc->next = pb;
			pc = pb;
			pb = pb->next;
		}
	}
	pc->next = (pa) ? pa : pb;
}
/**************************************************************************
功能：创建单向无头结点循环链表
说明：头结点置空，在建立新结点时，将通过判断头结点是否为空来初始化头结点，
每次插入的节点都作为尾结点，并将其指针域置空，直到最后将为结点和头结点相连，构成无头结点循环链表.
**************************************************************************/
LNode* CreatList(int n)
{
	LNode *h;
	LNode *r, *p;
	h = new LNode;
	h = NULL;
	r = NULL;
	for (int i = 1; i <= n; i++)
	{
		p = new LNode;
		p->data = i;
		p->next = NULL;
		if (h == NULL)
		{
			h = p;
			r = h;
		}
		else
			r->next = p;
		r = p;
	}
	r->next = h;
	return h;
}
